<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Calorimetry & Energy Transfer — Interactive Simulation (Y11)</title>
<style>
  :root{
    --bg:#f7f9fc;
    --panel:#ffffff;
    --ink:#1f2937;
    --muted:#6b7280;
    --brand:#2563eb;
    --accent:#10b981;    /* green */
    --purple:#8b5cf6;    /* purple */
    --warn:#f59e0b;
    --error:#ef4444;
    --a:#3b82f6;       /* A main (sensible) */
    --a-latent:#a855f7;/* A latent */
    --b:#f59e0b;       /* B main (sensible) */
    --b-latent:#8b5cf6;/* B latent */
    --grid:#e5e7eb;
    --chip:#eef2ff;
    --good:#16a34a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system, Segoe UI, Roboto, Inter, Arial;
    background:var(--bg); color:var(--ink); line-height:1.4;
  }
  header{
    padding:1rem 1.25rem 0.75rem; border-bottom:1px solid var(--grid);
    background:linear-gradient(180deg,#fff, #f9fbff);
    position:sticky; top:0; z-index:3;
  }
  h1{margin:.2rem 0 .4rem; font-size:1.45rem}
  header .sub{color:var(--muted); font-size:.95rem}
  main{padding:1rem; max-width:1200px; margin:0 auto}
  .layout{display:grid; grid-template-columns:1fr 1fr; gap:1rem}
  @media (max-width: 1000px){ .layout{grid-template-columns:1fr} }
  .card{
    background:var(--panel); border:1px solid var(--grid); border-radius:12px;
    padding:1rem; box-shadow:0 1px 0 rgba(0,0,0,.03);
  }
  .row{display:grid; grid-template-columns:1fr 1fr; gap:.75rem}
  .row-3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:.75rem}
  .row-4{display:grid; grid-template-columns:repeat(4,1fr); gap:.75rem}
  .controls{display:flex; gap:.75rem; flex-wrap:wrap; align-items:center}
  label{font-size:.9rem; color:var(--muted); display:block; margin-bottom:.25rem}
  input[type=number], input[type=text], select{
    width:100%; padding:.5rem .6rem; font-size:1rem; border:1px solid var(--grid);
    border-radius:10px; background:#fff; color:#111827;
    transition:border-color .15s, box-shadow .15s, background .15s;
  }
  input[readonly]{background:#fbfbfb}
  input[type=range]{width:100%}
  .chip{
    display:inline-flex; align-items:center; gap:.4rem; padding:.3rem .6rem;
    background:var(--chip); border-radius:999px; font-size:.85rem; color:#334155; border:1px solid #dbeafe;
  }
  .mode{display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; margin:.35rem 0 .75rem;}
  .btn{
    background:var(--brand); color:#fff; border:none; border-radius:10px;
    padding:.65rem 1rem; font-weight:600; cursor:pointer;
    box-shadow:0 1px 0 rgba(0,0,0,.05);
  }
  .btn.secondary{ background:#e2e8f0; color:#111827 }
  .btn:disabled{opacity:.6; cursor:not-allowed}
  .help{color:var(--muted); font-size:.85rem}
  .hr{height:1px; background:var(--grid); margin:.6rem 0}
  .title{
    display:flex; align-items:center; justify-content:space-between; gap:.5rem;
    margin-bottom:.5rem;
  }

  /* Energy bars */
  .bars{display:grid; gap:.75rem}
  .bar{ background:#eef2f7; border:1px dashed #d1d5db; border-radius:10px; padding:.5rem; }
  .bar .label{display:flex; justify-content:space-between; font-size:.9rem; color:var(--muted); margin-bottom:.25rem}
  .bar .track{ height:24px; border-radius:6px; background:#fff; border:1px solid #e5e7eb; overflow:hidden; position:relative; }
  .segment{height:100%}
  .segment.A{background:linear-gradient(90deg, var(--a), #60a5fa)}
  .segment.AL{background:linear-gradient(90deg, var(--a-latent), #c084fc)}
  .segment.B{background:linear-gradient(90deg, var(--b), #fbbf24)}
  .segment.BL{background:linear-gradient(90deg, var(--b-latent), #a78bfa)}
  .legend{display:flex; gap:.75rem; flex-wrap:wrap; font-size:.85rem; color:var(--muted); margin-top:.5rem}
  .legend .key{display:inline-flex; align-items:center; gap:.4rem}
  .legend .swatch{width:14px; height:8px; border-radius:2px}
  .sw-A{background:var(--a)} .sw-AL{background:var(--a-latent)} .sw-B{background:var(--b)} .sw-BL{background:var(--b-latent)}

  /* Results */
  .grid-results{display:grid; grid-template-columns:1fr 1fr; gap:1rem}
  @media (max-width: 900px){ .grid-results{grid-template-columns:1fr} }
  .result{font-size:1.05rem}
  .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--error)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}

  /* Tooltip */
  abbr[title]{text-decoration:none; border-bottom:1px dotted #94a3b8; cursor:help}

  .note{padding:.5rem .75rem; background:#f8fafc; border:1px solid #e5e7eb; border-radius:10px; color:#334155; font-size:.9rem}

  /* Highlighting: green vs purple */
  .greenBox{ border:2px solid #22c55e !important; background:#ecfdf5 !important; box-shadow:0 0 0 3px rgba(34,197,94,0.12) inset; }
  .purpleBox{ border:2px solid var(--purple) !important; background:#f5f3ff !important; box-shadow:0 0 0 3px rgba(139,92,246,0.10) inset; }

  /* Graph */
  #graphWrap{ border:1px solid var(--grid); border-radius:10px; background:#fff; padding:.5rem; }
  #tempChart{ width:100%; height:280px; display:block; }

  .tf-caption{ font-size:.8rem; color:var(--muted); margin-top:.25rem; }

  .equation{
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    background:#fff; border:1px solid var(--grid); border-radius:10px;
    padding:.6rem .8rem; overflow-x:auto; white-space:pre-wrap;
  }
  .eqLabel{color:#334155; font-weight:600; margin-bottom:.25rem}
  .eqSmall{color:#6b7280; font-size:.9rem; margin-top:.25rem}
</style>
</head>
<body>
<header>
  <h1>Calorimetry &amp; Energy Transfer — Interactive Simulation</h1>
  <div class="sub">Apply energy conservation, use <abbr title="Heat = mass × specific heat capacity × temperature change">Q = m c ΔT</abbr> and <abbr title="Latent heat = mass × latent heat">Q = m L</abbr>, and explore phase change.</div>
</header>

<main>
  <!-- Global Controls -->
  <section class="card">
    <div class="title">
      <div><strong>Mode</strong></div>
      <div class="controls">
        <span class="chip">All units: mass (kg), temp (°C), c (J·kg⁻¹·K⁻¹), L (J·kg⁻¹)</span>
      </div>
    </div>
    <div class="mode">
      <label class="chip"><input type="radio" name="mode" value="finalT" checked> Find Final Temperature</label>
      <label class="chip"><input type="radio" name="mode" value="unknownC"> Find Unknown Specific Heat</label>
      <label class="chip"><input type="checkbox" id="phaseToggle"> Include Phase Change</label>

      <!-- Q mode: new tick + box -->
      <label class="chip" title="Single-object for A using Q = m c ΔT">
        <input type="checkbox" id="useQ"> Q value (single A)
      </label>
      <label style="display:inline-flex; align-items:center; gap:.35rem">
        <span>Q (J)</span>
        <input type="number" id="QInput" step="1" style="width:160px" placeholder="enter Q or leave blank">
      </label>

      <button class="btn" id="calcBtn">Calculate</button>
      <button class="btn secondary" id="resetBtn" title="Reset to sensible defaults">Reset</button>
    </div>
    <div class="help">
      Unknown c mode disables phase change (derivation assumes no latent heat).<br>
      <strong>Q value (single A):</strong> Hides B. Enter <em>T<sub>f</sub></em> in A, then either type Q and leave c blank to solve <em>c</em>, or type c (for A) and leave Q blank to solve <em>Q</em>.
    </div>
  </section>

  <!-- Substances -->
  <section class="layout">
    <!-- Substance A -->
    <div class="card" id="cardA">
      <div class="title"><strong>Substance A</strong> <span class="chip">Blue</span></div>

      <div class="row">
        <div>
          <label>Preset</label>
          <select id="presetA"></select>
        </div>
        <div>
          <label>State</label>
          <select id="stateA" class="greenBox">
            <option value="solid">solid</option>
            <option value="liquid" selected>liquid</option>
            <option value="gas">gas</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Mass m<sub>A</sub> (kg)</label>
          <input type="number" step="0.01" id="mA" value="0.20" min="0" class="greenBox">
        </div>
        <div>
          <label>Initial Temperature T<sub>A,i</sub> (°C)</label>
          <input type="number" step="0.1" id="TAi" value="80" class="greenBox">
        </div>
      </div>

      <!-- Final temperature box -->
      <div class="row">
        <div>
          <label>Final Temperature T<sub>f</sub> (°C)</label>
          <input type="text" id="TfA_box" value="—" readonly class="greenBox">
          <div class="tf-caption">Shared equilibrium (two-body) OR editable (Q mode)</div>
        </div>
        <div></div>
      </div>

      <div id="cABlock">
        <label><abbr title="Specific heat capacity">c</abbr> (J·kg⁻¹·K⁻¹)</label>
        <input type="number" step="1" id="cA" value="4186" min="0" class="greenBox" placeholder="leave blank to solve c from Q">
      </div>

      <div id="cAStates" style="display:none">
        <div class="row-3">
          <div>
            <label>c<sub>solid</sub> (J·kg⁻¹·K⁻¹)</label>
            <input type="number" step="1" id="cA_s" value="2100" min="0" class="purpleBox">
          </div>
          <div>
            <label>c<sub>liquid</sub> (J·kg⁻¹·K⁻¹)</label>
            <input type="number" step="1" id="cA_l" value="4186" min="0" class="greenBox">
          </div>
          <div>
            <label>c<sub>gas</sub> (J·kg⁻¹·K⁻¹)</label>
            <input type="number" step="1" id="cA_g" value="2010" min="0" class="purpleBox">
          </div>
        </div>
        <div class="row-4" style="margin-top:.5rem">
          <div>
            <label>T<sub>m</sub> (°C)</label>
            <input type="number" step="0.1" id="TmA" value="0" class="purpleBox">
          </div>
          <div>
            <label>T<sub>b</sub> (°C)</label>
            <input type="number" step="0.1" id="TbA" value="100" class="purpleBox">
          </div>
          <div>
            <label>L<sub>f</sub> (J·kg⁻¹)</label>
            <input type="number" step="1000" id="LfA" value="334000" class="purpleBox">
          </div>
          <div>
            <label>L<sub>v</sub> (J·kg⁻¹)</label>
            <input type="number" step="10000" id="LvA" value="2256000" class="purpleBox">
          </div>
        </div>
        <div style="margin-top:.5rem">
          <label class="chip"><input type="checkbox" id="predictA"> I think Substance A will change state</label>
        </div>
      </div>

      <div class="help">Use presets, then adjust if needed. <abbr title="c = specific heat capacity">c</abbr> is per state when phase change is on.</div>
    </div>

    <!-- Substance B -->
    <div class="card" id="cardB">
      <div class="title"><strong>Substance B</strong> <span class="chip">Orange</span></div>

      <div class="row">
        <div>
          <label>Preset</label>
          <select id="presetB"></select>
        </div>
        <div>
          <label>State</label>
          <select id="stateB" class="greenBox">
            <option value="solid" selected>solid</option>
            <option value="liquid">liquid</option>
            <option value="gas">gas</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Mass m<sub>B</sub> (kg)</label>
          <input type="number" step="0.01" id="mB" value="0.10" min="0" class="greenBox">
        </div>
        <div>
          <label>Initial Temperature T<sub>B,i</sub> (°C)</label>
          <input type="number" step="0.1" id="TBi" value="-10" class="greenBox">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Final Temperature T<sub>f</sub> (°C)</label>
          <input type="text" id="TfB_box" value="—" readonly class="greenBox">
          <div class="tf-caption">Shared equilibrium (same for A & B)</div>
        </div>
        <div></div>
      </div>

      <div id="cBBlock">
        <label><abbr title="Specific heat capacity">c</abbr> (J·kg⁻¹·K⁻¹)</label>
        <input type="number" step="1" id="cB" value="2100" min="0" class="greenBox">
      </div>

      <div id="cBStates" style="display:none">
        <div class="row-3">
          <div>
            <label>c<sub>solid</sub> (J·kg⁻¹·K⁻¹)</label>
            <input type="number" step="1" id="cB_s" value="2100" min="0" class="greenBox">
          </div>
          <div>
            <label>c<sub>liquid</sub> (J·kg⁻¹·K⁻¹)</label>
            <input type="number" step="1" id="cB_l" value="4186" min="0" class="purpleBox">
          </div>
          <div>
            <label>c<sub>gas</sub> (J·kg⁻¹·K⁻¹)</label>
            <input type="number" step="1" id="cB_g" value="2010" min="0" class="purpleBox">
          </div>
        </div>
        <div class="row-4" style="margin-top:.5rem">
          <div>
            <label>T<sub>m</sub> (°C)</label>
            <input type="number" step="0.1" id="TmB" value="0" class="purpleBox">
          </div>
          <div>
            <label>T<sub>b</sub> (°C)</label>
            <input type="number" step="0.1" id="TbB" value="100" class="purpleBox">
          </div>
          <div>
            <label>L<sub>f</sub> (J·kg⁻¹)</label>
            <input type="number" step="1000" id="LfB" value="334000" class="purpleBox">
          </div>
          <div>
            <label>L<sub>v</sub> (J·kg⁻¹)</label>
            <input type="number" step="10000" id="LvB" value="2256000" class="purpleBox">
          </div>
        </div>
        <div style="margin-top:.5rem">
          <label class="chip"><input type="checkbox" id="predictB"> I think Substance B will change state</label>
        </div>
      </div>

      <div class="help">Try an “ice in hot water” classic: A = water at 80 °C, B = ice at −10 °C.</div>
    </div>
  </section>

  <!-- Equation used -->
  <section class="card">
    <div class="title"><strong>Energy Balance Equation (used)</strong></div>
    <div class="eqLabel">Heat lost by the hotter side = Heat gained by the colder side</div>
    <div id="eqSym" class="equation">—</div>
    <div id="eqNum" class="equation" style="margin-top:.5rem">—</div>
    <div class="eqSmall">Signs: we show positive terms on each side. During phase change, a fraction φ·mL appears if only part of the phase change occurs.</div>
  </section>

  <!-- Results & Visuals -->
  <section class="layout" style="margin-top:1rem">
    <div class="card">
      <div class="title"><strong>Results</strong></div>
      <div class="grid-results">
        <div class="result" id="resultMain">
          <div><strong id="headline"></strong></div>
          <div class="hr"></div>
          <div id="details"></div>
          <div class="hr"></div>
          <div id="consCheck" class="mono"></div>
          <div id="notes" class="help" style="margin-top:.4rem"></div>
        </div>
        <div class="result" id="derivation" style="display:none">
          <div><strong>Algebra (Unknown c)</strong></div>
          <div class="hr"></div>
          <div class="mono" id="workings" style="white-space:pre-wrap"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="title"><strong>Visual: Temperature vs Steps</strong></div>
      <div id="graphWrap">
        <canvas id="tempChart" width="900" height="280" aria-label="Temperature graph for A and B"></canvas>
      </div>

      <div class="hr" style="margin-top:.75rem"></div>

      <div class="bars">
        <div class="bar">
          <div class="label"><span>Energy change Q<sub>A</sub></span><span id="QA_lab">0 J</span></div>
          <div class="track" id="barA"></div>
        </div>
        <div class="bar" id="barB_wrap">
          <div class="label"><span>Energy change Q<sub>B</sub></span><span id="QB_lab">0 J</span></div>
          <div class="track" id="barB"></div>
        </div>
        <div class="legend">
          <span class="key"><span class="swatch sw-A"></span> sensible (A)</span>
          <span class="key"><span class="swatch sw-AL"></span> latent (A)</span>
          <span class="key"><span class="swatch sw-B"></span> sensible (B)</span>
          <span class="key"><span class="swatch sw-BL"></span> latent (B)</span>
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="title"><strong>Quick Reminders</strong></div>
    <div class="row">
      <div class="note">
        <strong>Energy conservation:</strong> In an isolated system, <span class="mono">Q<sub>A</sub> + Q<sub>B</sub> = 0</span>.  
        Positive Q = heat gained; negative Q = heat released.
      </div>
      <div class="note">
        <strong>Phase change:</strong> Temperature remains constant during melting/boiling while latent heat is absorbed/released.  
        Use <span class="mono">Q = m L</span> at <span class="mono">T<sub>m</sub></span> or <span class="mono">T<sub>b</sub></span>.
      </div>
    </div>
  </section>
</main>

<script>
/* ===========================================================
   Calorimetry Simulation — Year 11
   Author: M365 Copilot for Andy Cockerill
   -----------------------------------------------------------
   HOW TO CUSTOMISE:
   - DEFAULTS: See 'setDefaults()' near the end.
   - ADD PRESETS: Add entries in 'PRESETS' below.
   - ASSUMPTIONS: Perfectly isolated system; no heat loss; uniform T; no chemistry.
   =========================================================== */

const PRESETS = {
  "Water (H₂O)": {
    statesC: { solid:2100, liquid:4186, gas:2010 },
    Tm: 0, Tb: 100, Lf: 334000, Lv: 2256000
  },
  "Aluminium (Al)": {
    statesC: { solid:900, liquid:1000, gas:900 },
    Tm: 660, Tb: 2470, Lf: 397000, Lv: 10500000
  },
  "Copper (Cu)": {
    statesC: { solid:385, liquid:500, gas:385 },
    Tm: 1085, Tb: 2562, Lf: 205000, Lv: 4800000
  },
  "Iron (Fe)": {
    statesC: { solid:450, liquid:820, gas:450 },
    Tm: 1538, Tb: 2862, Lf: 247000, Lv: 6300000
  }
};

/* ---------- Helpers ---------- */
const $ = sel => document.querySelector(sel);
const clamp = (x,a,b)=> Math.max(a, Math.min(b,x));
const fmtNum = (x, sig=3) => {
  if (!isFinite(x)) return "—";
  const ax = Math.abs(x);
  if (ax === 0) return "0";
  if (ax>=1e4 || ax<1e-2) return x.toExponential(sig-1);
  return Number(x.toPrecision(sig)).toString();
};
const fmtJ = (x)=> `${fmtNum(x,4)} J`;

/* ---------- DOM refs ---------- */
const modeRadios = [...document.getElementsByName('mode')];
const phaseToggle = $('#phaseToggle');
const calcBtn = $('#calcBtn');
const resetBtn = $('#resetBtn');

const useQ = $('#useQ');               /* NEW */
const QInput = $('#QInput');           /* NEW */

const presetA = $('#presetA'), presetB = $('#presetB');
const stateA = $('#stateA'), stateB = $('#stateB');
const mA = $('#mA'), mB = $('#mB');
const TAi = $('#TAi'), TBi = $('#TBi');
const cA = $('#cA'), cB = $('#cB');
const cA_s = $('#cA_s'), cA_l = $('#cA_l'), cA_g = $('#cA_g');
const cB_s = $('#cB_s'), cB_l = $('#cB_l'), cB_g = $('#cB_g');
const TmA = $('#TmA'), TbA = $('#TbA'), LfA = $('#LfA'), LvA = $('#LvA');
const TmB = $('#TmB'), TbB = $('#TbB'), LfB = $('#LfB'), LvB = $('#LvB');
const cABlock = $('#cABlock'), cBBlock = $('#cBBlock');
const cAStates = $('#cAStates'), cBStates = $('#cBStates');
const predictA = $('#predictA'), predictB = $('#predictB');

const headline = $('#headline'), details = $('#details'), consCheck = $('#consCheck');
const notes = $('#notes'), derivation = $('#derivation'), workings = $('#workings');

const barA = $('#barA'), barB = $('#barB');
const barB_wrap = $('#barB_wrap');
const QA_lab = $('#QA_lab'), QB_lab = $('#QB_lab');

const TfA_box = $('#TfA_box'), TfB_box = $('#TfB_box');
const tempCanvas = $('#tempChart');
const ctx = tempCanvas.getContext('2d');

/* Equation block */
const eqSym = $('#eqSym');
const eqNum = $('#eqNum');

/* ---------- Populate presets ---------- */
function populatePresets(){
  const keys = Object.keys(PRESETS);
  for(const s of [presetA, presetB]){
    s.innerHTML = '';
    keys.forEach((k,i)=>{
      const opt = document.createElement('option');
      opt.value = k; opt.textContent = k;
      if (i===0) opt.selected = true;
      s.appendChild(opt);
    });
  }
}

/* ---------- Apply preset ---------- */
function applyPreset(side, presetName){
  const ps = PRESETS[presetName];
  if (!ps) return;
  if (side==='A'){
    cA_s.value = ps.statesC.solid;
    cA_l.value = ps.statesC.liquid;
    cA_g.value = ps.statesC.gas;
    TmA.value = ps.Tm; TbA.value = ps.Tb; LfA.value = ps.Lf; LvA.value = ps.Lv;
    if (!phaseToggle.checked) cA.value = ps.statesC[stateA.value] ?? ps.statesC.liquid;
  } else {
    cB_s.value = ps.statesC.solid;
    cB_l.value = ps.statesC.liquid;
    cB_g.value = ps.statesC.gas;
    TmB.value = ps.Tm; TbB.value = ps.Tb; LfB.value = ps.Lf; LvB.value = ps.Lv;
    if (!phaseToggle.checked) cB.value = ps.statesC[stateB.value] ?? ps.statesC.liquid;
  }
  updateHighlights();
}

/* ---------- UI switching ---------- */
function getMode(){
  const r = modeRadios.find(x=>x.checked);
  return r ? r.value : 'finalT';
}
function syncPhaseUI(){
  const on = phaseToggle.checked;
  cABlock.style.display = on ? 'none' : 'block';
  cBBlock.style.display = on ? 'none' : 'block';
  cAStates.style.display = on ? 'block' : 'none';
  cBStates.style.display = on ? 'block' : 'none';
  if (on && getMode()==='unknownC'){
    modeRadios.find(r=>r.value==='finalT').checked = true;
  }
  updateHighlights();
}

/* ---------- Q mode: show/hide B and make A's Tf editable ---------- */
function syncQModeUI(){
  const on = useQ.checked;
  const cardB = $('#cardB');
  if (on){
    // Hide B panel and B bar
    cardB.style.display = 'none';
    barB_wrap.style.display = 'none';
    // Make A's Tf editable as number
    try{ TfA_box.type = 'number'; }catch(e){}
    TfA_box.readOnly = false;
    TfA_box.step = '0.1';
    if (TfA_box.value==='—' || TfA_box.value==='') TfA_box.value = '20';
    // Clear two-body equation box to avoid confusion; will show single equation here
    eqSym.textContent = '—';
    eqNum.textContent = '—';
  } else {
    // Show B and bar again
    cardB.style.display = '';
    barB_wrap.style.display = '';
    // Restore TfA to readonly text indicator
    try{ TfA_box.type = 'text'; }catch(e){}
    TfA_box.readOnly = true;
    TfA_box.value = '—';
    // Also clear Q input display if needed
  }
}

/* ---------- Highlighting logic ---------- */
function makePurple(elList){
  elList.forEach(el=>{ if(el){ el.classList.add('purpleBox'); el.classList.remove('greenBox'); }});
}
function makeGreen(elList){
  elList.forEach(el=>{ if(el){ el.classList.add('greenBox'); el.classList.remove('purpleBox'); }});
}
function updateHighlights(){
  makeGreen([stateA, mA, TAi, TfA_box]);
  makeGreen([stateB, mB, TBi, TfB_box]);

  if (!phaseToggle.checked){
    makeGreen([cA, cB]);
  } else {
    const cA_map = {solid:cA_s, liquid:cA_l, gas:cA_g};
    const cB_map = {solid:cB_s, liquid:cB_l, gas:cB_g};
    Object.values(cA_map).forEach(x=>x && x.classList.add('purpleBox'));
    makeGreen([cA_map[stateA.value]]);
    Object.values(cB_map).forEach(x=>x && x.classList.add('purpleBox'));
    makeGreen([cB_map[stateB.value]]);
    makePurple([TmA, TbA, LfA, LvA, TmB, TbB, LfB, LvB]);
  }
}

/* ---------- Physics: no phase change ---------- */
function finalT_noPhase(params){
  const {mA, cA, TAi, mB, cB, TBi} = params;
  const denom = mA*cA + mB*cB;
  if (denom === 0) return {Tf: NaN, QA: NaN, QB: NaN, history:[]};
  const Tf = (mA*cA*TAi + mB*cB*TBi) / denom;
  const QA = mA*cA*(Tf - TAi);
  const QB = mB*cB*(Tf - TBi);
  return {
    Tf, QA, QB,
    breakdownA:{sens:QA, lat:0}, breakdownB:{sens:QB, lat:0},
    history:[{Ta:TAi, Tb:TBi}, {Ta:Tf, Tb:Tf}]
  };
}
function cByState(cS, cL, cG, state){
  if (state==='solid') return Number(cS);
  if (state==='gas') return Number(cG);
  return Number(cL);
}

/* ---------- Two-body phase-change simulation with history ---------- */
function simulate_with_phase(A, B){
  const a = JSON.parse(JSON.stringify(A));
  const b = JSON.parse(JSON.stringify(B));
  let QA = 0, QB = 0;
  let A_sens = 0, A_lat = 0, B_sens = 0, B_lat = 0;
  const history = [{Ta:a.T, Tb:b.T}];

  const getC = (x)=> cByState(x.cS, x.cL, x.cG, x.state);
  function nextThresholdT(x, dir){
    if (dir>0){ if (x.state==='solid') return x.Tm; if (x.state==='liquid') return x.Tb; return +Infinity; }
    else if (dir<0){ if (x.state==='gas') return x.Tb; if (x.state==='liquid') return x.Tm; return -Infinity; }
    return x.T;
  }
  function moveTo(x, Tnew){
    const c = getC(x);
    const dQ = x.m * c * (Tnew - x.T);
    x.T = Tnew;
    return dQ;
  }
  function doLatent(x, dir, wantEnergy){
    if (x.state==='solid' && dir>0 && x.T===x.Tm){
      const need = x.m * x.Lf;
      const use = Math.sign(wantEnergy)===Math.sign(need) ? Math.min(Math.abs(wantEnergy), Math.abs(need)) : 0;
      const used = Math.sign(need) * use;
      if (Math.abs(used) >= Math.abs(need) - 1e-12){ x.state = 'liquid'; }
      return used;
    }
    if (x.state==='liquid' && dir<0 && x.T===x.Tm){
      const release = - x.m * x.Lf;
      const use = Math.sign(wantEnergy)===Math.sign(release) ? Math.min(Math.abs(wantEnergy), Math.abs(release)) : 0;
      const used = Math.sign(release) * use;
      if (Math.abs(used) >= Math.abs(release) - 1e-12){ x.state = 'solid'; }
      return used;
    }
    if (x.state==='liquid' && dir>0 && x.T===x.Tb){
      const need = x.m * x.Lv;
      const use = Math.sign(wantEnergy)===Math.sign(need) ? Math.min(Math.abs(wantEnergy), Math.abs(need)) : 0;
      const used = Math.sign(need) * use;
      if (Math.abs(used) >= Math.abs(need) - 1e-12){ x.state = 'gas'; }
      return used;
    }
    if (x.state==='gas' && dir<0 && x.T===x.Tb){
      const release = - x.m * x.Lv;
      const use = Math.sign(wantEnergy)===Math.sign(release) ? Math.min(Math.abs(wantEnergy), Math.abs(release)) : 0;
      const used = Math.sign(release) * use;
      if (Math.abs(used) >= Math.abs(release) - 1e-12){ x.state = 'liquid'; }
      return used;
    }
    return 0;
  }

  const MAX_STEPS = 200;
  for (let step=0; step<MAX_STEPS; step++){
    if (Math.abs(a.T - b.T) < 1e-10) break;

    let hot = a.T > b.T ? a : b;
    let cold = a.T > b.T ? b : a;
    const hotIsA = (hot===a);

    const cHot = getC(hot), cCold = getC(cold);
    const mHot = hot.m, mCold = cold.m;
    const denom = mHot*cHot + mCold*cCold;
    if (denom===0) break;
    const Tf_sensible = (mHot*cHot*hot.T + mCold*cCold*cold.T) / denom;

    const Thot_next = nextThresholdT(hot, -1);
    const Tcold_next = nextThresholdT(cold, +1);
    const dTh = Tf_sensible - hot.T;  // negative
    const dTc = Tf_sensible - cold.T; // positive
    const fracHot = (isFinite(Thot_next) && (hot.T - Thot_next)>0 && dTh!==0) ? ((hot.T - Thot_next)/Math.abs(dTh)) : Infinity;
    const fracCold = (isFinite(Tcold_next) && (Tcold_next - cold.T)>0 && dTc!==0) ? ((Tcold_next - cold.T)/Math.abs(dTc)) : Infinity;

    if (fracHot>=1 && fracCold>=1){
      const dQhot = moveTo(hot, Tf_sensible);
      const dQcold = moveTo(cold, Tf_sensible);
      if (hotIsA){ A_sens += dQhot; B_sens += dQcold; } else { B_sens += dQhot; A_sens += dQcold; }
      history.push({Ta:a.T, Tb:b.T});
      continue;
    }

    if (fracHot < fracCold){
      const Ttarget = Thot_next;
      const oldTh = hot.T, oldTc = cold.T;
      const dQh = moveTo(hot, Ttarget);
      const dQc = moveTo(cold, oldTc + ( (Ttarget - oldTh)*(mHot*cHot)/(mCold*cCold) ));
      if (hotIsA){ A_sens += dQh; B_sens += dQc; } else { B_sens += dQh; A_sens += dQc; }
      history.push({Ta:a.T, Tb:b.T});
      const Q_cold_to_thresh = mCold*cCold*(Ttarget - cold.T);
      if (Q_cold_to_thresh !== 0){
        const used = doLatent(hot, -1, -Q_cold_to_thresh);
        const sens_used = -used;
        const newTc = cold.T + sens_used/(mCold*cCold);
        const dQc2 = moveTo(cold, newTc);
        if (hotIsA){ A_lat += used; B_sens += dQc2; } else { B_lat += used; A_sens += dQc2; }
        history.push({Ta:a.T, Tb:b.T});
      }
    } else {
      const Ttarget = Tcold_next;
      const oldTh = hot.T, oldTc = cold.T;
      const dQc = moveTo(cold, Ttarget);
      const dQh = moveTo(hot, oldTh + ( (Ttarget - oldTc)*(mCold*cCold)/(mHot*cHot) ));
      if (hotIsA){ B_sens += dQc; A_sens += dQh; } else { A_sens += dQc; B_sens += dQh; }
      history.push({Ta:a.T, Tb:b.T});
      const Q_hot_to_thresh = mHot*cHot*(Ttarget - hot.T);
      if (Q_hot_to_thresh !== 0){
        const used = doLatent(cold, +1, -Q_hot_to_thresh);
        const sens_used = -used;
        const newTh = hot.T + sens_used/(mHot*cHot);
        const dQh2 = moveTo(hot, newTh);
        if (hotIsA){ B_lat += used; A_sens += dQh2; } else { A_lat += used; B_sens += dQh2; }
        history.push({Ta:a.T, Tb:b.T});
      }
    }
  }

  QA = A_sens + A_lat;
  QB = B_sens + B_lat;

  return {
    Tf: (a.T + b.T)/2,
    A: a, B: b,
    QA, QB,
    breakdownA: {sens:A_sens, lat:A_lat},
    breakdownB: {sens:B_sens, lat:B_lat},
    history
  };
}

/* ---------- Read inputs ---------- */
function readParams(){
  const phase = phaseToggle.checked;
  return {
    phase,
    A:{
      m: Number(mA.value),
      T: Number(TAi.value),
      state: stateA.value,
      c: Number(cA.value),
      cS: Number(cA_s.value), cL: Number(cA_l.value), cG: Number(cA_g.value),
      Tm: Number(TmA.value), Tb: Number(TbA.value),
      Lf: Number(LfA.value), Lv: Number(LvA.value),
      label: `A (${presetA.value})`
    },
    B:{
      m: Number(mB.value),
      T: Number(TBi.value),
      state: stateB.value,
      c: Number(cB.value),
      cS: Number(cB_s.value), cL: Number(cB_l.value), cG: Number(cB_g.value),
      Tm: Number(TmB.value), Tb: Number(TbB.value),
      Lf: Number(LfB.value), Lv: Number(LvB.value),
      label: `B (${presetB.value})`
    }
  };
}

/* ---------- Build equation text (two-body) ---------- */
function buildEquation(p, result){
  const Tf = result.Tf;
  const eps = 1e-9;

  function phasePath(x, Ti){
    const parts = [x.state];
    const up = Tf > Ti + eps;
    const down = Tf < Ti - eps;
    if (up){
      if (x.state==='solid' && Tf> x.Tm + eps) parts.push('liquid');
      if ((x.state==='solid' || x.state==='liquid') && Tf> x.Tb + eps) parts.push('gas');
    } else if (down){
      if (x.state==='gas' && Tf< x.Tb - eps) parts.push('liquid');
      if ((x.state==='gas' || x.state==='liquid') && Tf< x.Tm - eps) parts.push('solid');
    }
    return parts.join(' → ');
  }

  function stageTerms(side, breakdownLatJ){
    const terms = [];
    const x = side;
    const Ti0 = side.T;
    let Ti = Ti0;
    let state = side.state;
    const m = side.m;
    const cS = side.cS, cL = side.cL, cG = side.cG;
    const Tm = side.Tm, Tb = side.Tb;
    const Lf = side.Lf, Lv = side.Lv;

    const up = Tf > Ti + eps;
    const down = Tf < Ti - eps;
    let latAbs = Math.abs(breakdownLatJ || 0);
    function add(termSym, termNum, valJ){
      if (Math.abs(valJ) > 1e-12){
        terms.push({sym:termSym, num:termNum, J: Math.abs(valJ)});
      }
    }

    if (!up && !down) return terms;

    if (up){
      if (state==='solid'){
        if (Tf <= Tm + eps){
          add(`m c_s (T_f − T_i)`, `${m}·${cS}·(${(Tf-Ti).toFixed(3)})`, m*cS*(Tf-Ti)); return terms;
        } else {
          add(`m c_s (T_m − T_i)`, `${m}·${cS}·(${(Tm-Ti).toFixed(3)})`, m*cS*(Tm-Ti));
          const Lfull = m*Lf;
          if (Tf > Tm + eps){ add(`m L_f`, `${m}·${Lf}`, Lfull); latAbs = Math.max(0, latAbs - Lfull); state='liquid'; Ti=Tm; }
          else { const used = Math.min(Lfull, latAbs); const phi = used>0 ? used/Lfull : 0; add(`φ·m L_f (φ=${phi.toFixed(2)})`, `${phi.toFixed(2)}·${m}·${Lf}`, used); return terms; }
        }
      }
      if (state==='liquid'){
        if (Tf <= Tb + eps){
          add(`m c_l (T_f − T)`, `${m}·${cL}·(${(Tf-Ti).toFixed(3)})`, m*cL*(Tf-Ti)); return terms;
        } else {
          add(`m c_l (T_b − T)`, `${m}·${cL}·(${(Tb-Ti).toFixed(3)})`, m*cL*(Tb-Ti));
          const Lfull = m*Lv;
          if (Tf > Tb + eps){ add(`m L_v`, `${m}·${Lv}`, Lfull); latAbs = Math.max(0, latAbs - Lfull); state='gas'; Ti=Tb; }
          else { const used = Math.min(Lfull, latAbs); const phi = used>0 ? used/Lfull : 0; add(`φ·m L_v (φ=${phi.toFixed(2)})`, `${phi.toFixed(2)}·${m}·${Lv}`, used); return terms; }
        }
      }
      if (state==='gas'){ add(`m c_g (T_f − T)`, `${m}·${cG}·(${(Tf-Ti).toFixed(3)})`, m*cG*(Tf-Ti)); return terms; }
    } else if (down){
      if (state==='gas'){
        if (Tf >= Tb - eps){ add(`m c_g (T_i − T_f)`, `${m}·${cG}·(${(Ti-Tf).toFixed(3)})`, m*cG*(Ti-Tf)); return terms; }
        else {
          add(`m c_g (T_i − T_b)`, `${m}·${cG}·(${(Ti-Tb).toFixed(3)})`, m*cG*(Ti-Tb));
          const Lfull = m*Lv;
          if (Tf < Tb - eps){ add(`m L_v`, `${m}·${Lv}`, Lfull); latAbs = Math.max(0, latAbs - Lfull); state='liquid'; Ti=Tb; }
          else { const used = Math.min(Lfull, latAbs); const phi = used>0 ? used/Lfull : 0; add(`φ·m L_v (φ=${phi.toFixed(2)})`, `${phi.toFixed(2)}·${m}·${Lv}`, used); return terms; }
        }
      }
      if (state==='liquid'){
        if (Tf >= Tm - eps){ add(`m c_l (T − T_f)`, `${m}·${cL}·(${(Ti-Tf).toFixed(3)})`, m*cL*(Ti-Tf)); return terms; }
        else {
          add(`m c_l (T − T_m)`, `${m}·${cL}·(${(Ti-Tm).toFixed(3)})`, m*cL*(Ti-Tm));
          const Lfull = m*Lf;
          if (Tf < Tm - eps){ add(`m L_f`, `${m}·${Lf}`, Lfull); latAbs = Math.max(0, latAbs - Lfull); state='solid'; Ti=Tm; }
          else { const used = Math.min(Lfull, latAbs); const phi = used>0 ? used/Lfull : 0; add(`φ·m L_f (φ=${phi.toFixed(2)})`, `${phi.toFixed(2)}·${m}·${Lf}`, used); return terms; }
        }
      }
      if (state==='solid'){ add(`m c_s (T − T_f)`, `${m}·${cS}·(${(Ti-Tf).toFixed(3)})`, m*cS*(Ti-Tf)); return terms; }
    }
    return terms;
  }

  const QA = result.QA, QB = result.QB;
  const hotSide = (QA < 0) ? {side:'A', data:p.A, Q:QA, lat:result.breakdownA.lat} :
                    (QB < 0) ? {side:'B', data:p.B, Q:QB, lat:result.breakdownB.lat} : {side:'A', data:p.A, Q:QA, lat:result.breakdownA.lat};
  const coldSide = (hotSide.side==='A') ? {side:'B', data:p.B, Q:QB, lat:result.breakdownB.lat}
                                        : {side:'A', data:p.A, Q:QA, lat:result.breakdownA.lat};

  let termsHot = [], termsCold = [];
  if (!p.phase){
    const h = hotSide.data, c = coldSide.data;
    const dTh = Math.abs(Tf - h.T);
    const dTc = Math.abs(Tf - c.T);
    const ch = (hotSide.side==='A') ? (p.A.c) : (p.B.c);
    const cc = (coldSide.side==='A') ? (p.A.c) : (p.B.c);
    termsHot.push({sym:`m_${hotSide.side} c_${hotSide.side} (T_{i} − T_{f})`,
                   num:`${h.m}·${ch}·(${dTh.toFixed(3)})`,
                   J: Math.abs(h.m*ch*(Tf - h.T))});
    termsCold.push({sym:`m_${coldSide.side} c_${coldSide.side} (T_{f} − T_{i})`,
                    num:`${c.m}·${cc}·(${dTc.toFixed(3)})`,
                    J: Math.abs(c.m*cc*(Tf - c.T))});
  } else {
    termsHot = stageTerms(hotSide.data, hotSide.lat);
    termsCold = stageTerms(coldSide.data, coldSide.lat);
  }

  const hotLbl = `${hotSide.data.label} [${phasePath(hotSide.data, hotSide.data.T)}]`;
  const coldLbl = `${coldSide.data.label} [${phasePath(coldSide.data, coldSide.data.T)}]`;

  function joinSyms(ts){ return ts.map(t=>t.sym).join(' + '); }
  function joinNums(ts){ return ts.map(t=>t.num).join(' + '); }
  function sumJ(ts){ return ts.reduce((a,b)=>a + (b.J||0), 0); }

  const symStr = `(${hotLbl}) :  ${joinSyms(termsHot)}  =  (${coldLbl}) :  ${joinSyms(termsCold)}`;
  const numStr = `${joinNums(termsHot)}  =  ${joinNums(termsCold)}
⇒ ${fmtJ(sumJ(termsHot))}  =  ${fmtJ(sumJ(termsCold))}`;

  return {symStr, numStr};
}

/* ---------- Compute & render ---------- */
function computeAndRender(){
  const qMode = useQ.checked;

  if (qMode){
    // Single-object (A) using Q = m c ΔT
    const m = Number(mA.value);
    const Ti = Number(TAi.value);
    const Tf = Number(TfA_box.value);
    const c = (cA.value==='' ? NaN : Number(cA.value));
    const Q = (QInput.value==='' ? NaN : Number(QInput.value));

    const bad = (msg)=>{
      headline.innerHTML = '';
      details.innerHTML = '';
      consCheck.textContent = '';
      notes.textContent = '';
      eqSym.textContent = '—'; eqNum.textContent = '—';
      QA_lab.textContent = '0 J'; QB_lab.textContent = '0 J';
      barA.innerHTML = ''; barB.innerHTML = '';
      // keep graph minimal
      renderGraph([{Ta:isFinite(Ti)?Ti:0, Tb:isFinite(Ti)?Ti:0}]);
      updateHighlights();
      // Show message in details
      details.innerHTML = `<span class="bad">${msg}</span>`;
    };

    if (!isFinite(m) || m<=0) return bad('Please enter a valid mass m > 0 for A.');
    if (!isFinite(Ti) || !isFinite(Tf)) return bad('Please enter valid T₍i₎ and T₍f₎ for A.');
    const dT = Tf - Ti;
    if (!isFinite(dT) || dT===0) return bad('Temperature change ΔT must be non‑zero.');

    let solvedQ = null, solvedC = null, modeText = '';
    if (!isNaN(Q) && isNaN(c)){
      // Solve for c
      solvedC = Q / (m * dT);
      if (!isFinite(solvedC)) return bad('Unable to compute c — check Q, m, and ΔT.');
      cA.value = solvedC; // fill result to UI
      modeText = 'Computed specific heat (A)';
      headline.innerHTML = `${modeText}: <strong>${fmtNum(solvedC,5)} J·kg⁻¹·K⁻¹</strong>`;
      eqSym.textContent = `c = Q / (m ΔT)`;
      eqNum.textContent = `c = ${Q} / (${m} · (${Tf} − ${Ti})) = ${fmtNum(solvedC,5)} J·kg⁻¹·K⁻¹`;
      // For visuals, we can also show Q implied by result:
      const impliedQ = m * solvedC * dT;
      QA_lab.textContent = fmtJ(impliedQ);
      QB_lab.textContent = '0 J';
      renderBars(impliedQ, 0, {sens:impliedQ, lat:0}, {sens:0,lat:0});
    } else {
      // Prefer computing Q if c given or both given
      const cUse = isNaN(c) ? null : c;
      if (cUse===null) return bad('Enter Q (to solve c) OR enter c (to solve Q).');
      solvedQ = m * cUse * dT;
      modeText = 'Computed heat (A)';
      headline.innerHTML = `${modeText}: <strong>${fmtJ(solvedQ)}</strong> (${solvedQ>=0?'absorbed (warming)':'released (cooling)'})`;
      eqSym.textContent = `Q = m c (T_f − T_i)`;
      eqNum.textContent = `Q = ${m} · ${cUse} · (${Tf} − ${Ti}) = ${fmtJ(solvedQ)}`;
      QA_lab.textContent = fmtJ(solvedQ);
      QB_lab.textContent = '0 J';
      renderBars(solvedQ, 0, {sens:solvedQ, lat:0}, {sens:0,lat:0});
    }

    // Details + notes; clear two-body conservation line (not applicable)
    details.innerHTML = `Using A only: m = ${m} kg, ΔT = ${(dT).toFixed(3)} K.`;
    consCheck.textContent = 'Single-object calculation (B removed).';
    notes.textContent = 'Sign convention — Q>0 for heat absorbed (warming), Q<0 for heat released (cooling).';

    // Graph: A from Ti→Tf; keep B line hidden but plot stays okay
    renderGraph([{Ta:Ti, Tb:TBi.value?Number(TBi.value):0}, {Ta:Tf, Tb:TBi.value?Number(TBi.value):0}]);

    // Done with Q mode
    return;
  }

  // NORMAL two-body routes
  const p = readParams();
  let result = null;
  const mode = getMode();

  if (mode==='finalT'){
    if (!p.phase){
      result = finalT_noPhase({
        mA:p.A.m, cA:p.A.c, TAi:p.A.T, mB:p.B.m, cB:p.B.c, TBi:p.B.T
      });
      headline.innerHTML = `Final equilibrium temperature <strong>T<sub>f</sub> = ${fmtNum(result.Tf,4)} °C</strong>`;
      details.innerHTML =
        `Q<sub>A</sub> = m<sub>A</sub> c<sub>A</sub> (T<sub>f</sub> − T<sub>A,i</sub>) = ${fmtJ(result.QA)}<br>`+
        `Q<sub>B</sub> = m<sub>B</sub> c<sub>B</sub> (T<sub>f</sub> − T<sub>B,i</sub>) = ${fmtJ(result.QB)}<br>`+
        `<em>${result.QA>0?'A gained heat;':''} ${result.QA<0?'A released heat;':''} ${result.QB>0?'B gained heat;':''} ${result.QB<0?'B released heat;':''}</em>`;
      notes.textContent = 'Phase change disabled: only sensible heating/cooling considered.';
    } else {
      const sim = simulate_with_phase(
        {
          m:p.A.m, T:p.A.T, state:p.A.state,
          cS:p.A.cS, cL:p.A.cL, cG:p.A.cG,
          Tm:p.A.Tm, Tb:p.A.Tb, Lf:p.A.Lf, Lv:p.A.Lv,
          label:p.A.label
        },
        {
          m:p.B.m, T:p.B.T, state:p.B.state,
          cS:p.B.cS, cL:p.B.cL, cG:p.B.cG,
          Tm:p.B.Tm, Tb:p.B.Tb, Lf:p.B.Lf, Lv:p.B.Lv,
          label:p.B.label
        }
      );
      result = sim;
      headline.innerHTML = `Final equilibrium temperature <strong>T<sub>f</sub> = ${fmtNum(sim.Tf,4)} °C</strong>`;
      const pcA = Math.abs(sim.breakdownA.lat) > 1e-9;
      const pcB = Math.abs(sim.breakdownB.lat) > 1e-9;
      const predA = $('#predictA').checked;
      const predB = $('#predictB').checked;
      const predTxt =
        `<div style="margin-top:.4rem">
          Prediction check: A ${predA? (pcA?'<span class="ok">✅ correct</span>':'<span class="bad">✖ incorrect</span>'): '—'}; 
          B ${predB? (pcB?'<span class="ok">✅ correct</span>':'<span class="bad">✖ incorrect</span>'): '—'}
        </div>`;
      details.innerHTML =
        `<strong>Energy breakdown</strong><br>
         A: sensible = ${fmtJ(sim.breakdownA.sens)}, latent = ${fmtJ(sim.breakdownA.lat)}<br>
         B: sensible = ${fmtJ(sim.breakdownB.sens)}, latent = ${fmtJ(sim.breakdownB.lat)}<br>
         <em>${sim.QA>0?'A gained heat;':''} ${sim.QA<0?'A released heat;':''} ${sim.QB>0?'B gained heat;':''} ${sim.QB<0?'B released heat;':''}</em>` + predTxt;
      notes.textContent = 'During phase change, the temperature pauses at Tm or Tb while latent heat is absorbed/released.';
    }
  } else if (mode==='unknownC'){
    const which = prompt("Which substance has unknown specific heat? Type 'A' or 'B'.", "A");
    if (!which || !['A','B','a','b'].includes(which.trim())) {
      headline.textContent = 'Unknown specific heat: cancelled.';
      details.textContent = '';
      consCheck.textContent = '';
      renderBars(0,0,{sens:0,lat:0},{sens:0,lat:0});
      renderGraph([{Ta:Number(TAi.value), Tb:Number(TBi.value)}]);
      eqSym.textContent = '—'; eqNum.textContent = '—';
      return;
    }
    const Tf_meas = Number(prompt("Enter measured final temperature T_f (°C):", "20"));
    if (!isFinite(Tf_meas)){
      headline.textContent = 'Please provide a valid measured T_f next time.';
      details.textContent = '';
      consCheck.textContent = '';
      renderGraph([{Ta:Number(TAi.value), Tb:Number(TBi.value)}]);
      TfA_box.value = '—'; TfB_box.value = '—';
      eqSym.textContent = '—'; eqNum.textContent = '—';
      return;
    }
    const mA_ = Number(mA.value), mB_ = Number(mB.value);
    const TAi_ = Number(TAi.value), TBi_ = Number(TBi.value);
    const cA_ = Number(cA.value), cB_ = Number(cB.value);
    let calcC, work;

    if (which.toUpperCase()==='A'){
      calcC = - (mB_ * cB_ * (Tf_meas - TBi_)) / (mA_ * (Tf_meas - TAi_));
      work =
`Start:  m_A c_A (T_f - T_{A,i}) + m_B c_B (T_f - T_{B,i}) = 0
=>      m_A c_A (ΔT_A) = - m_B c_B (ΔT_B)
=>      c_A = - [ m_B c_B (ΔT_B) ] / [ m_A (ΔT_A) ]

Substitute:
ΔT_A = (${Tf_meas} − ${TAi_}) K
ΔT_B = (${Tf_meas} − ${TBi_}) K

c_A = - [ (${mB_})·(${cB_})·(${Tf_meas - TBi_}) ] / [ (${mA_})·(${Tf_meas - TAi_}) ]
    = ${fmtNum(calcC,5)} J·kg⁻¹·K⁻¹`;
    } else {
      calcC = - (mA_ * cA_ * (Tf_meas - TAi_)) / (mB_ * (Tf_meas - TBi_));
      work =
`Start:  m_A c_A (T_f - T_{A,i}) + m_B c_B (T_f - T_{B,i}) = 0
=>      m_B c_B (ΔT_B) = - m_A c_A (ΔT_A)
=>      c_B = - [ m_A c_A (ΔT_A) ] / [ m_B (ΔT_B) ]

Substitute:
ΔT_A = (${Tf_meas} − ${TAi_}) K
ΔT_B = (${Tf_meas} − ${TBi_}) K

c_B = - [ (${mA_})·(${cA_})·(${Tf_meas - TAi_}) ] / [ (${mB_})·(${Tf_meas - TBi_}) ]
    = ${fmtNum(calcC,5)} J·kg⁻¹·K⁻¹`;
    }

    headline.innerHTML = `Calculated unknown specific heat: <strong>${fmtNum(calcC,5)} J·kg⁻¹·K⁻¹</strong>`;
    details.innerHTML = `Using measured T<sub>f</sub> = ${fmtNum(Tf_meas,4)} °C in an isolated system (no latent heat).`;
    workings.textContent = work;

    const cA_used = (which.toUpperCase()==='A') ? calcC : cA_;
    const cB_used = (which.toUpperCase()==='B') ? calcC : cB_;
    const QA = mA_ * cA_used * (Tf_meas - TAi_);
    const QB = mB_ * cB_used * (Tf_meas - TBi_);
    result = {
      Tf: Tf_meas,
      QA, QB,
      breakdownA:{sens:QA, lat:0}, breakdownB:{sens:QB, lat:0},
      history:[{Ta:TAi_, Tb:TBi_}, {Ta:Tf_meas, Tb:Tf_meas}]
    };
    notes.textContent = 'Phase change intentionally disabled in Unknown c mode.';
  }

  // Common rendering (two-body)
  if (result){
    TfA_box.value = `${fmtNum(result.Tf,4)} °C`;
    TfB_box.value = `${fmtNum(result.Tf,4)} °C`;

    const sum = result.QA + result.QB;
    const mag = Math.max(1, Math.abs(result.QA) + Math.abs(result.QB));
    const rel = Math.abs(sum)/mag;
    const status = rel<1e-10 ? 'ok' : (rel<1e-3 ? 'warn' : 'bad');
    consCheck.innerHTML = `Energy conservation check: Q_A + Q_B = ${fmtJ(sum)}  →  <span class="${status}">${status==='ok'?'OK':(status==='warn'?'≈ OK (small rounding)':'Check inputs')}</span>`;

    renderBars(result.QA, result.QB, result.breakdownA, result.breakdownB);
    renderGraph(result.history);

    const eq = buildEquation(readParams(), result);
    eqSym.textContent = eq.symStr;
    eqNum.textContent = eq.numStr;
  } else {
    TfA_box.value = '—'; TfB_box.value = '—';
    renderBars(0,0,{sens:0,lat:0},{sens:0,lat:0});
    renderGraph([{Ta:Number(TAi.value), Tb:Number(TBi.value)}]);
    eqSym.textContent = '—'; eqNum.textContent = '—';
  }

  QA_lab.textContent = result ? fmtJ(result.QA) : '0 J';
  QB_lab.textContent = result ? fmtJ(result.QB) : '0 J';

  updateHighlights();
}

/* ---------- Energy bars ---------- */
function renderBars(QA, QB, A_parts, B_parts){
  const maxAbs = Math.max(1, Math.abs(QA), Math.abs(QB));
  function makeBar(track, total, parts, who){
    track.innerHTML = '';
    const sens = parts?.sens ?? total;
    const lat = parts?.lat ?? 0;
    const dir = total>=0 ? 1 : -1;
    const sensW = Math.min(100, Math.abs(sens)/maxAbs*100);
    const latW = Math.min(100, Math.abs(lat)/maxAbs*100);
    if (sensW>0){
      const d = document.createElement('div');
      d.className = 'segment ' + (who==='A'?'A':'B');
      d.style.width = sensW+'%';
      d.style.float = dir>0?'left':'right';
      track.appendChild(d);
    }
    if (latW>0){
      const d = document.createElement('div');
      d.className = 'segment ' + (who==='A'?'AL':'BL');
      d.style.width = latW+'%';
      d.style.float = dir>0?'left':'right';
      track.appendChild(d);
    }
  }
  makeBar(barA, QA, A_parts, 'A');
  makeBar(barB, QB, B_parts, 'B');
}

/* ---------- Temperature graph (Canvas) ---------- */
function renderGraph(history){
  const W = tempCanvas.width, H = tempCanvas.height;
  ctx.clearRect(0,0,W,H);

  const padL=60, padR=20, padT=20, padB=35;
  const plotW = W - padL - padR;
  const plotH = H - padT - padB;

  if (!history || history.length===0){
    ctx.fillStyle = '#64748b';
    ctx.fillText('No data to plot.', padL+10, padT+20);
    return;
  }

  let Tmin = +Infinity, Tmax = -Infinity;
  history.forEach(p=>{
    Tmin = Math.min(Tmin, p.Ta, p.Tb);
    Tmax = Math.max(Tmax, p.Ta, p.Tb);
  });
  if (!isFinite(Tmin) || !isFinite(Tmax)) { Tmin=-10; Tmax=40; }
  if (Math.abs(Tmax - Tmin) < 1e-6){ Tmax = Tmin + 1; }
  const span = Tmax - Tmin;
  const padSpan = span * 0.1 + 1;
  Tmin -= padSpan; Tmax += padSpan;

  const N = history.length;
  const xAt = i => padL + (N===1?0:(i/(N-1))*plotW);
  const yAt = T => padT + (1 - (T - Tmin)/(Tmax - Tmin)) * plotH;

  // Grid
  ctx.lineWidth = 1; ctx.strokeStyle = '#cbd5e1';
  ctx.beginPath();
  for (let g=0; g<=5; g++){
    const y = padT + (g/5)*plotH;
    ctx.moveTo(padL, y); ctx.lineTo(W - padR, y);
  }
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#334155';
  ctx.font = '12px system-ui, Segoe UI, Roboto';
  ctx.fillText('Steps', padL + plotW/2 - 18, H - 8);
  ctx.textAlign='right';
  for (let g=0; g<=5; g++){
    const Ty = Tmin + (1 - g/5)*(Tmax - Tmin);
    ctx.fillText(`${Ty.toFixed(1)} °C`, padL - 8, padT + (g/5)*plotH + 4);
  }
  ctx.textAlign='left';

  // Lines
  function drawLine(color, key){
    ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = color;
    history.forEach((p,i)=>{
      const x = xAt(i), y = yAt(p[key]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
    ctx.fillStyle = color;
    history.forEach((p,i)=>{
      const x = xAt(i), y = yAt(p[key]);
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
    });
  }
  drawLine('#3b82f6','Ta'); // A
  drawLine('#f59e0b','Tb'); // B

  // Legend
  ctx.fillStyle = '#3b82f6'; ctx.fillRect(W - padR - 150, padT + 6, 12, 12);
  ctx.fillStyle = '#f59e0b'; ctx.fillRect(W - padR - 150, padT + 26, 12, 12);
  ctx.fillStyle = '#334155';
  ctx.fillText('A temperature', W - padR - 130, padT + 16);
  ctx.fillText('B temperature', W - padR - 130, padT + 36);
}

/* ---------- Defaults ---------- */
function setDefaults(){
  populatePresets();
  presetA.value = "Water (H₂O)";
  presetB.value = "Water (H₂O)";
  applyPreset('A', presetA.value);
  applyPreset('B', presetB.value);

  stateA.value = 'liquid';
  mA.value = 0.20;
  TAi.value = 80;

  stateB.value = 'solid';
  mB.value = 0.10;
  TBi.value = -10;

  phaseToggle.checked = true;
  syncPhaseUI();
  TfA_box.value = '—'; TfB_box.value = '—';

  // Q mode off by default
  useQ.checked = false;
  QInput.value = '';
  syncQModeUI();
}

/* ---------- Events ---------- */
presetA.addEventListener('change', ()=> applyPreset('A', presetA.value));
presetB.addEventListener('change', ()=> applyPreset('B', presetB.value));

[stateA, stateB].forEach(sel=>{
  sel.addEventListener('change', ()=>{
    if (!phaseToggle.checked){
      const ps = PRESETS[(sel===stateA?presetA:presetB).value];
      if (ps){
        const cval = ps.statesC[sel.value] ?? ps.statesC.liquid;
        (sel===stateA?cA:cB).value = cval;
      }
    }
    updateHighlights();
  });
});

phaseToggle.addEventListener('change', ()=>{ syncPhaseUI(); });
useQ.addEventListener('change', ()=>{ syncQModeUI(); });          /* NEW */
QInput.addEventListener('input', ()=>{/* no-op; read at calc */});/* NEW */

calcBtn.addEventListener('click', computeAndRender);
resetBtn.addEventListener('click', ()=>{ setDefaults(); computeAndRender(); });

document.addEventListener('keydown', (e)=>{
  if (e.key==='Enter' && !['INPUT','SELECT','TEXTAREA'].includes(document.activeElement.tagName)) {
    computeAndRender();
  }
});

/* ---------- Init ---------- */
setDefaults();
computeAndRender();
updateHighlights();

</script>
</body>
</html>
